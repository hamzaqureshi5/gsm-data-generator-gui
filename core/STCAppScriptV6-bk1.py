"""
STC_APP_Scriptv6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
    Author : Hamza Qureshi

DESCRIPTION
This code include following :
1. Create demo data dynamic method
2. Generate all parameters added by user from Application/settings.json[Working Fine]
3. Get input file
4. Create output CSV or Text files [data, laser and server files] as well
"""

# !pip install pycryptodome
# you can use requirements.txt
# from core.GlobalParams import PARAMETERS, DATA_FRAMES
from globals.parameters import PARAMETERS, DATA_FRAMES

# from custom_json import JsonHandler
from typing import Optional, List, Dict, Any, Tuple

# from pydantic import BaseModel, Field
from Crypto.Cipher import AES
from io import BytesIO
import secrets
import pandas as pd
import collections
import binascii
import datetime
import random
import string
import uuid
import json
import time
import os

CONFIGURATION_FILE_PATH = "settings.json"

# default_headers = [
#     "ICCID",
#     "IMSI",
#     "PIN1",
#     "PUK1",
#     "PIN2",
#     "PUK2",
#     "KI",
#     "EKI",
#     "OPC",
#     "ADM1",
#     "ADM6",
#     "ACC",
# ]

default_headers = (
    "ICCID",
    "IMSI",
    "OP",
    "K4",
    "PIN1",
    "PUK1",
    "PIN2",
    "PUK2",
    "KI",
    "EKI",
    "OPC",
    "ADM1",
    "ADM6",
    "ACC",
    "KIC1",
    "KID1",
    "KIK1",
    "KIC2",
    "KID2",
    "KIK2",
    "KIC3",
    "KID3",
    "KIK3",
)


class CryptoUtils:
    @staticmethod
    def aes_128_cbc_encrypt(key: str, text: str) -> str:
        iv = binascii.unhexlify("00000000000000000000000000000000")
        key_bytes = binascii.unhexlify(key)
        text_bytes = binascii.unhexlify(text)
        encryptor = AES.new(key_bytes, AES.MODE_CBC, IV=iv)
        ciphertext = encryptor.encrypt(text_bytes)
        return ciphertext.hex().upper()

    @staticmethod
    def xor_str(s: bytes, t: bytes) -> bytes:
        return bytes([_a ^ _b for _a, _b in zip(s, t)])

    @staticmethod
    def calc_opc_hex(k_hex: str, op_hex: str) -> str:
        iv = binascii.unhexlify(16 * "00")
        ki = binascii.unhexlify(k_hex)
        op = binascii.unhexlify(op_hex)
        aes_crypt = AES.new(ki, mode=AES.MODE_CBC, IV=iv)
        data = op
        o_pc = CryptoUtils.xor_str(data, aes_crypt.encrypt(data))
        return o_pc.hex().upper()


class DataGenerator:
    @staticmethod
    def generate_ki() -> str:
        return secrets.token_hex(16).upper()

    @staticmethod
    def generate_otas() -> str:
        return secrets.token_hex(16).upper()

    @staticmethod
    def generate_k4() -> str:
        return secrets.token_hex(32).upper()

    @staticmethod
    def generate_8_digit() -> str:
        return str(secrets.SystemRandom().randint(10000000, 99999999))

    @staticmethod
    def generate_4_digit() -> str:
        return str(secrets.SystemRandom().randint(1000, 9999))

    @staticmethod
    def generate_opc(op: str, ki: str) -> str:
        return CryptoUtils.calc_opc_hex(ki, op).upper()

    @staticmethod
    def generate_eki(transport: str, ki: str) -> str:
        return CryptoUtils.aes_128_cbc_encrypt(transport, ki)


def copy_function(x):
    return str(x)


#  return str("0002")


# code below is for Demo Data generation, what if we have to gernate Data from ICCID and IMSI given
# we have to read input file and copy content [ICCID, IMSI] from input file and generate Parameters based on input File


# def read_json(file_path: str):
#     with open(file_path, "r") as json_file:
#         data = json.load(json_file)
#     return dict(data)


def read_json(file_path: str):
    try:
        with open(file_path, "r") as json_file:
            data = json.load(json_file)
        return dict(data)
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        return None  # You can choose to return None or raise a custom exception here
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON in '{file_path}': {e}")
        return None  # You can choose to return None or raise a custom exception here


class EncodingUtils:
    @staticmethod
    def enc_pin(pin: str) -> str:
        return EncodingUtils.rpad(EncodingUtils.s2h(pin), 16).upper()

    @staticmethod
    def dec_pin(encoded_pin: str) -> str:
        return EncodingUtils.h2s(encoded_pin).upper()

    @staticmethod
    def enc_imsi(imsi: str) -> str:
        l = EncodingUtils.half_round_up(len(imsi) + 1)
        oe = len(imsi) & 1
        ei = f"{l:02x}" + EncodingUtils.swap_nibbles(
            f"{(oe << 3) | 1:01x}{EncodingUtils.rpad(imsi, 15)}"
        )
        return ei

    @staticmethod
    def dec_imsi(ef: str) -> Optional[str]:
        if len(ef) < 4:
            return None
        l = int(ef[0:2], 16) * 2 - 1
        swapped = EncodingUtils.swap_nibbles(ef[2:]).rstrip("f")
        if len(swapped) < 1:
            return None
        oe = (int(swapped[0]) >> 3) & 1
        if not oe:
            l -= 1
        if l != len(swapped) - 1:
            return None
        return swapped[1:]

    @staticmethod
    def enc_iccid(iccid: str) -> str:
        luhn = EncodingUtils.calculate_luhn(iccid)
        iccid_with_luhn = iccid + str(luhn)
        return EncodingUtils.swap_nibbles(
            EncodingUtils.rpad(iccid_with_luhn, 20)
        ).upper()

    @staticmethod
    def dec_iccid(ef: str) -> str:
        return EncodingUtils.swap_nibbles(ef.upper()).strip("F")[:-1]

    @staticmethod
    def swap_nibbles(s: str) -> str:
        return "".join([x + y for x, y in zip(s[1::2], s[0::2])])

    @staticmethod
    def rpad(s: str, l: int, c: str = "f") -> str:
        return s + c * (l - len(s))

    @staticmethod
    def lpad(s: str, l: int, c: str = "f") -> str:
        return c * (l - len(s)) + s

    @staticmethod
    def half_round_up(n: int) -> int:
        return (n + 1) // 2

    @staticmethod
    def calculate_luhn(cc: str) -> int:
        num = list(map(int, str(cc)))
        check_digit = (
            10 - sum(num[-2::-2] + [sum(divmod(d * 2, 10)) for d in num[::-2]]) % 10
        )
        return 0 if check_digit == 10 else check_digit

    @staticmethod
    def h2b(s: str) -> bytearray:
        return bytearray.fromhex(s)

    @staticmethod
    def b2h(b: bytearray) -> str:
        return "".join([f"{x:02x}" for x in b])

    @staticmethod
    def h2i(s: str) -> List[int]:
        return [(int(x, 16) << 4) + int(y, 16) for x, y in zip(s[0::2], s[1::2])]

    @staticmethod
    def i2h(s: List[int]) -> str:
        return "".join([f"{x:02x}" for x in s])

    @staticmethod
    def h2s(s: str) -> str:
        return "".join(
            [
                chr((int(x, 16) << 4) + int(y, 16))
                for x, y in zip(s[0::2], s[1::2])
                if int(x + y, 16) != 0xFF
            ]
        )

    @staticmethod
    def s2h(s: str) -> str:
        return EncodingUtils.b2h(bytearray(map(ord, s)))

    @staticmethod
    def i2s(s: List[int]) -> str:
        return "".join([chr(x) for x in s])


class DataProcessing:
    @staticmethod
    def generate_acc(imsi: str) -> str:
        last_digit = int(imsi[-1])
        acc_binary = bin(1 << last_digit)[2:].zfill(16)
        return format(int(acc_binary, 2), "04x")

    @staticmethod
    def split_range(input_string: str) -> Tuple[int, int]:
        if input_string and "-" in input_string and len(input_string) > 2:
            values = input_string.split("-")
            return int(values[0]), int(values[1])
        return 0, 32

    @staticmethod
    def extract_ranges(ranges: List[str]) -> Tuple[List[int], List[int]]:
        left_ranges, right_ranges = [], []
        for range_str in ranges:
            left, right = DataProcessing.split_range(range_str)
            left_ranges.append(left)
            right_ranges.append(right)
        return left_ranges, right_ranges

    @staticmethod
    def find_duplicates(items: List[Any]) -> List[Any]:
        return [item for item, count in collections.Counter(items).items() if count > 1]

    @staticmethod
    def extract_parameter_info(
        param_dict: Dict[str, List[str]]
    ) -> Tuple[List[str], List[str], set, List[str], List[int], List[int]]:
        values, classes, ranges = [], [], []
        for item in param_dict.values():
            values.append(item[0])
            classes.append(item[1])
            ranges.append(item[2])

        renamed_values = DataProcessing.append_count_to_duplicates(values)
        duplicate_values = DataProcessing.find_duplicates(values)
        unique_values = set(values)
        left_ranges, right_ranges = DataProcessing.extract_ranges(ranges)

        return (
            renamed_values,
            duplicate_values,
            unique_values,
            classes,
            left_ranges,
            right_ranges,
        )

    @staticmethod
    def append_count_to_duplicates(input_list: List[str]) -> List[str]:
        output_list = []
        element_counts: Dict[str, int] = {}

        for element in input_list:
            if element in element_counts:
                element_counts[element] += 1
                output_list.append(f"{element}{element_counts[element]}")
            else:
                element_counts[element] = 0
                output_list.append(element)

        return output_list


class DataFrameProcessor:
    @staticmethod
    def generate_empty_dataframe(columns: List[str], rows: str) -> pd.DataFrame:
        empty_data = [{col: 0 for col in columns} for _ in range(int(rows))]
        return pd.DataFrame(empty_data)

    @staticmethod
    def initialize_column(
        df: pd.DataFrame, column: str, start_value: str, increment: bool = True
    ) -> None:
        if increment:
            df[column] = range(int(start_value), int(start_value) + len(df))
        else:
            df[column] = str(start_value)

    @staticmethod
    def apply_function_to_column(
        df: pd.DataFrame, dest_col: str, src_col: str, func: callable
    ) -> None:
        if dest_col in df.columns:
            df[dest_col] = df[src_col].apply(func)

    @staticmethod
    def clip_columns(
        df: pd.DataFrame, left_ranges: List[int], right_ranges: List[int]
    ) -> pd.DataFrame:
        for col, left, right in zip(df.columns, left_ranges, right_ranges):
            df[col] = df[col].apply(lambda x: x[left : right + 1])
        return df

    @staticmethod
    def add_duplicate_columns(
        df: pd.DataFrame, limit: int, headers: List[str]
    ) -> pd.DataFrame:
        for c in range(limit):
            for col in df.columns:
                new_col = f"{col}{c}"
                if new_col in headers:
                    df[new_col] = df[col]
        return df[headers]

    @staticmethod
    def encode_dataframe(df: pd.DataFrame) -> pd.DataFrame:
        encoding_map = {
            "ICCID": EncodingUtils.enc_iccid,
            "IMSI": EncodingUtils.enc_imsi,
            "PIN1": EncodingUtils.enc_pin,
            "PUK1": EncodingUtils.s2h,
            "PIN2": EncodingUtils.enc_pin,
            "PUK2": EncodingUtils.s2h,
            "ADM1": EncodingUtils.s2h,
            "ADM6": EncodingUtils.s2h,
        }
        for col, func in encoding_map.items():
            if col in df.columns:
                df[col] = df[col].apply(func)
        return df

    @staticmethod
    def decode_dataframe(df: pd.DataFrame) -> pd.DataFrame:
        decoding_map = {
            "ICCID": EncodingUtils.dec_iccid,
            "IMSI": EncodingUtils.dec_imsi,
            "PIN1": EncodingUtils.dec_pin,
            "PUK1": EncodingUtils.h2s,
            "PIN2": EncodingUtils.dec_pin,
            "PUK2": EncodingUtils.h2s,
            "ADM1": EncodingUtils.h2s,
        }
        for col, func in decoding_map.items():
            if col in df.columns:
                df[col] = df[col].apply(func)
        return df


# class STCAppParameters(BaseModel):
#     k4: str = Field(..., min_length=64, max_length=64)
#     op: str = Field(..., min_length=32, max_length=32)
#     imsi_start: int = Field(..., ge=100000000000000, le=999999999999999)
#     iccid_start: int = Field(..., ge=1000000000000000000, le=9999999999999999999)
#     pin1: str = Field(..., min_length=4, max_length=4)
#     puk1: str = Field(..., min_length=8, max_length=8)
#     pin2: str = Field(..., min_length=4, max_length=4)
#     puk2: str = Field(..., min_length=8, max_length=8)
#     adm1: str = Field(..., min_length=8, max_length=8)
#     adm6: str = Field(..., min_length=8, max_length=8)
#     acc: str = Field(..., min_length=4, max_length=4)
#     data_size: int = Field(..., gt=0)
#     production_check: bool
#     elect_check: bool
#     graph_check: bool
#     server_check: bool
#     input_path: str
#     pin1_rand: bool
#     puk1_rand: bool
#     pin2_rand: bool
#     puk2_rand: bool
#     adm1_rand: bool
#     adm6_rand: bool
#     acc_rand: bool
#     server_dict: Dict[str, List[str]]
#     elect_dict: Dict[str, List[str]]
#     graph_dict: Dict[str, List[str]]
#     input_df: Optional[pd.DataFrame] = None

# class STCAppScript:
#     def __init__(self):
#         self.params = {}
#         self.dataframes = {}

#     def set_parameters(self, params: Dict[str, Any]) -> None:
#         self.params = params

#     def generate_data(self) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, Dict[str, str]]:
#         initial_df, keys_dict = self._generate_initial_dataframe()

#         server_df = self._process_dataframe(initial_df, self.params['server_dict'], False, False, "SERVER")
#         laser_df = self._process_dataframe(initial_df, self.params['graph_dict'], True, False, "LASER")
#         elect_df = self._process_dataframe(initial_df, self.params['elect_dict'], False, True, "ELECT")

#         return elect_df, laser_df, server_df, keys_dict

#     def _generate_initial_dataframe(self) -> Tuple[pd.DataFrame, Dict[str, str]]:
#         default_headers = [
#             "ICCID", "IMSI", "PIN1", "PUK1", "PIN2", "PUK2", "KI", "EKI", "OPC",
#             "ADM1", "ADM6", "ACC", "KIC1", "KID1", "KIK1", "KIC2", "KID2", "KIK2",
#             "KIC3", "KID3", "KIK3"
#         ]

#         if self.params['production_check']:
#             df = DataFrameProcessor.generate_empty_dataframe(default_headers, self.params['data_size'])
#             DataFrameProcessor.initialize_column(df, "ICCID", self.params['iccid_start'])
#             DataFrameProcessor.initialize_column(df, "IMSI", self.params['imsi_start'])
#         else:
#             df = DataFrameProcessor.generate_empty_dataframe(default_headers, len(self.params['input_df']))
#             df["ICCID"] = self.params['input_df']["ICCID"]
#             df["IMSI"] = self.params['input_df']["IMSI"]

#         self._apply_data_generation_functions(df)

#         keys_dict = {"k4": self.params['k4'], "op": self.params['op']}
#         return df, keys_dict

#     def _apply_data_generation_functions(self, df: pd.DataFrame) -> None:
#         DataFrameProcessor.apply_function_to_column(df, "KI", "KI", DataGenerator.generate_ki)
#         DataFrameProcessor.apply_function_to_column(df, "EKI", "KI", lambda x: DataGenerator.generate_eki(self.params['k4'], x))
#         DataFrameProcessor.apply_function_to_column(df, )


def list_2_dict(list: list) -> dict:
    dict = {}
    for index in range(0, len(list)):
        dict[str(index)] = [list[index], "Normal", "0-31"]
    return dict


def dict_2_list(d: dict) -> list:
    list1 = []
    for index, j in enumerate(d):
        temp = list(d.values())[index][0]
        list1.append(temp)
    return list1


# # input_elect_params = {
# #     "0": ["ICCID", "Normal", "0-18"],
# #     "1": ["ICCID", "Normal", "10-20"],
# #     "2": ["ICCID", "Normal", "0-14"],
# #     "3": ["IMSI", "Normal", "0-14"],
# #     "4": ["PIN1", "Normal", "0-14"],
# # }


# from operators.zong.FileParser import ZongFileParser
# from json_utils import JsonHandler
# s = DataGenerationScript()
# j=JsonHandler()
# factory_data_json_path = CONFIGURATION_FILE_PATH
# j.read_paths()
# j.read_variables()
# s.SET_ALL_DISP_PARAMS()  # testing
# s.SET_HEADERS()

# (
#     s.dataframes.__ELECT_DF,
#     s.dataframes.__GRAPH_DF,
#     s.dataframes.__SERVR_DF,
#     s.dataframes.__KEYS,
# ) = s._preview_files_gets()


# print(s.dataframes.__ELECT_DF)
# print(s.dataframes.__GRAPH_DF)
# print(s.dataframes.__SERVR_DF)


# # m_zong = ZongGenerateHandle()

# # m_zong.set_json_to_UI()
# # m_zong.Generate_laser_file("AAA",s.dataframes.GRAPH_DF)
# # m_zong.Generate_servr_file("ASD",s.dataframes.SERVR_DF)
# # m_zong.Generate_elect_file("ASD",s.dataframes.ELECT_DF)


class DataGenerationScript1:
    def __init__(self):
        self.params = PARAMETERS.get_instance()
        self.dataframes = DATA_FRAMES.get_instance()
        self.crypto_utils = CryptoUtils()
        self.data_generator = DataGenerator()
        self.data_processor = DataProcessing()
        self.df_processor = DataFrameProcessor()

    def SET_ALL_DISP_PARAMS(self):
        self.params.set_K4(
            "111150987DE41E9F0808193003B543296D0A01D797B511AFDAEEEAC53BC61111"
        )
        self.params.set_OP("1111006F86FAD6540D86FEF24D261111")
        self.params.set_IMSI(999990000000400)
        self.params.set_ICCID(999900000000000400)
        self.params.set_PIN1("0000")
        self.params.set_PUK1("00000000")
        self.params.set_PIN2("5555")
        self.params.set_PUK2("4444")
        self.params.set_ADM1("11111111")
        self.params.set_ADM6("11111111")
        self.params.set_ACC("0111")
        self.params.set_DATA_SIZE(7)

        self.params.set_PRODUCTION_CHECK(False)
        self.params.set_ELECT_CHECK(True)
        self.params.set_GRAPH_CHECK(True)
        self.params.set_SERVER_CHECK(True)

        # self.params.set_SERVER_DICT(input_server_params)
        # self.params.set_ELECT_DICT(input_elect_params)
        # self.params.set_GRAPH_DICT(input_laser_params)
        #  params.set_INPUT_PATH("C:/Users/hamza.qureshi/Desktop/STC_APP/improvements/dataGen-v17/input.csv")
        self.params.set_INPUT_PATH("templates/N2023031016844011.txt")

        # ========================================#
        # ========================================#
        # ========================================#

        self.params.set_PIN1_RAND(False)
        self.params.set_PUK1_RAND(True)
        self.params.set_PIN2_RAND(False)
        self.params.set_PUK2_RAND(False)
        self.params.set_ADM1_RAND(False)
        self.params.set_ADM6_RAND(True)
        self.params.set_ACC_RAND(False)

    def generate_eki(self, ki):
        return self.data_generator.generate_eki(self.params.get_K4(), ki)

    def generate_opc(self, ki):
        return self.data_generator.generate_opc(self.params.get_OP(), ki)

    def generate_pin(self, pin_type):
        if getattr(self.params, f"get_{pin_type}_RAND")():
            return getattr(self.params, f"get_{pin_type}")()
        return self.data_generator.generate_4_digit()

    def generate_puk(self, puk_type):
        if getattr(self.params, f"get_{puk_type}_RAND")():
            return getattr(self.params, f"get_{puk_type}")()
        return self.data_generator.generate_8_digit()

    def generate_adm(self, adm_type):
        if getattr(self.params, f"get_{adm_type}_RAND")():
            return getattr(self.params, f"get_{adm_type}")()
        return self.data_generator.generate_8_digit()

    #    @staticmethod
    def apply_function(self, df, dest: str, src: str, function):
        if dest in df.columns:
            df[dest] = df[src].apply(function).copy(deep=False)

    def apply_functions(self, df):
        df["ICCID"] = df["ICCID"].apply(lambda x: copy_function(x))
        df["IMSI"] = df["IMSI"].apply(lambda x: copy_function(x))
        df["PIN1"] = df["PIN1"].apply(lambda x: self.generate_pin("PIN1"))
        df["PIN2"] = df["PIN2"].apply(lambda x: self.generate_pin("PIN2"))
        df["PUK1"] = df["PUK1"].apply(lambda x: self.generate_pin("PUK1"))
        df["PUK2"] = df["PUK2"].apply(lambda x: self.generate_pin("PUK2"))

        df["ADM1"] = df["ADM1"].apply(lambda x: self.generate_adm("ADM1"))
        df["ADM6"] = df["ADM6"].apply(lambda x: self.generate_adm("ADM6"))

        df["KI"] = df["KI"].apply(lambda x: self.data_generator.generate_ki())
        df["ACC"] = df["IMSI"].apply(
            lambda imsi: self.data_processor.generate_acc(imsi=str(imsi))
        )

        #        self.apply_function(df, "EKI", "KI", functions)
        self.apply_function(df, "EKI", "KI", self.generate_eki)
        self.apply_function(df, "OPC", "KI", self.generate_opc)

        for i in range(1, 4):
            for key in ["KIC", "KID", "KIK"]:
                col = f"{key}{i}"
                if col in df.columns:
                    df[col] = df["KI"].apply(
                        lambda x: self.data_generator.generate_otas()
                    )
        df.to_csv("temp.csv")
        return df

    #    @staticmethod
    def __apply_function(df, dest: str, src: str, function):
        if dest in df.columns:
            df[dest] = df[src].apply(function).copy(deep=False)

    def __Apply_functions(self, df, op_1, k4_1):
        #  print(k4_1,op_1)
        #  apply_function(df,'ICCID','ICCID',apply_luhn_check)
        self.__apply_function(df, "ICCID", "ICCID", copy_function)
        self.__apply_function(df, "IMSI", "IMSI", copy_function)

        if self.params.get_PIN1_RAND() is False:
            self.__apply_function(
                df, "PIN1", "PIN1", lambda x: self.generate_pin("PIN1")
            )  # Reason: PIN1 is fixed for now
        else:
            self.__apply_function(
                df, "PIN1", "PIN1", self.__PIN1_function
            )  # Reason: PIN1 is fixed for now

        if self.params.get_PUK1_RAND() is False:
            self.__apply_function(
                df, "PUK1", "PUK1", lambda x: self.generate_pin("PUK1")
            )
        else:
            self.__apply_function(df, "PUK1", "PUK1", self.__PUK1_function)

        if self.params.get_PIN2_RAND() is False:
            self.__apply_function(
                df, "PIN2", "PIN2", lambda x: self.generate_pin("PIN2")
            )
        else:
            self.__apply_function(df, "PIN2", "PIN2", self.__PIN2_function)

        if self.params.get_PUK2_RAND() is False:
            self.__apply_function(
                df, "PUK2", "PUK2", lambda x: self.generate_pin("PUK2")
            )
        else:
            self.__apply_function(df, "PUK2", "PUK2", self.__PUK2_function)

        if self.params.get_ADM1_RAND() is False:
            self.__apply_function(
                df, "ADM1", "ADM1", lambda x: self.generate_pin("ADM1")
            )
        else:
            self.__apply_function(df, "ADM1", "ADM1", self.__ADM1_function)

        if self.params.get_ADM6_RAND() is False:
            self.__apply_function(
                df, "ADM6", "ADM6", lambda x: self.generate_pin("ADM6")
            )
        else:
            self.__apply_function(df, "ADM6", "ADM6", self.__ADM6_function)

        self.__apply_function(
            df, "KI", "KI", lambda x: self.data_generator.generate_ki()
        )
        self.__apply_function(df, "EKI", "KI", self.generate_eki())
        #        self.__apply_function(df, "OPC", "EKI", self.__gen_opc_custom)
        self.__apply_function(df, "OPC", "KI", self.generate_opc())
        """ Change made on 30-10-2023 by hamza originally it was as commented """

        self.__apply_function(
            df, "KIC1", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KIC2", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KIC3", "KI", lambda x: self.data_generator.generate_otas()
        )

        self.__apply_function(
            df, "KID1", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KID2", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KID3", "KI", lambda x: self.data_generator.generate_otas()
        )

        self.__apply_function(
            df, "KIK1", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KIK2", "KI", lambda x: self.data_generator.generate_otas()
        )
        self.__apply_function(
            df, "KIK3", "KI", lambda x: self.data_generator.generate_otas()
        )

        self.__apply_function(df, "ACC", "IMSI", self.data_processor.generate_acc())

        return df

    def generate_demo_data(self):
        df = self.df_processor.generate_empty_dataframe(
            default_headers, self.params.get_DATA_SIZE()
        )

        print("-------> ", self.params.get_K4())
        self.df_processor.initialize_column(df, "ICCID", self.params.get_ICCID())
        self.df_processor.initialize_column(df, "IMSI", self.params.get_IMSI())

        self.df_processor.initialize_column(
            df, "OP", self.params.get_OP(), increment=False
        )
        self.df_processor.initialize_column(
            df, "K4", self.params.get_K4(), increment=False
        )
        return self.apply_functions(df)

    def generate_non_demo_data(self):
        input_df = self.dataframes.get_INPUT_DF()
        df = self.df_processor.generate_empty_dataframe(default_headers, len(input_df))
        #        self.df_processor.initialize_column(df, 'OP', self.params.get_OP(), increment=False)
        #        self.df_processor.initialize_column(df, 'K4', self.params.get_K4(), increment=False)
        df["ICCID"] = input_df["ICCID"]
        df["IMSI"] = input_df["IMSI"]
        return self.apply_functions(df)

    def generate_initial_data(self, is_demo: bool):
        if is_demo:
            return self.generate_demo_data(), {
                "k4": self.params.get_K4(),
                "op": self.params.get_OP(),
            }
        return self.generate_non_demo_data(), {
            "k4": self.params.get_K4(),
            "op": self.params.get_OP(),
        }

    def process_final_data(
        self, input_dict: dict, df_input: pd.DataFrame, clip: bool, encoding: bool
    ):
        df = df_input.copy(deep=True)
        if encoding:
            df = self.df_processor.encode_dataframe(df)

        headers, _, _, _, left_ranges, right_ranges = (
            self.data_processor.extract_parameter_info(input_dict)
        )
        df = self.df_processor.add_duplicate_columns(df, 10, headers)

        if clip:
            df = self.df_processor.clip_columns(df, left_ranges, right_ranges)

        return df

    def generate_all_data(self):
        # initial_df, keys_dict = self.generate_initial_data(
        #     self.params.get_PRODUCTION_CHECK()
        # )
        initial_df, keys_dict = self.generate_initial_data(True)
        print(initial_df.head())
        data_types = {bool, dict, bool, bool}
        data_types = {
            "SERVER": (
                self.params.get_SERVER_CHECK(),
                self.params.get_SERVER_DICT(),
                False,
                False,
            ),
            "GRAPH": (
                self.params.get_GRAPH_CHECK(),
                self.params.get_GRAPH_DICT(),
                True,
                False,
            ),
            "ELECT": (
                self.params.get_ELECT_CHECK(),
                self.params.get_ELECT_DICT(),
                False,
                True,
            ),
        }
        result_dfs = {}
        for data_type, (check, dict_func, clip, encoding) in data_types.items():
            if check:
                result_dfs[data_type] = self.process_final_data(
                    dict_func, initial_df, clip, encoding
                )
        return result_dfs, keys_dict

    def set_all_parameters(self):
        # Set default parameters
        params = {
            "K4": "111150987DE41E9F0808193003B543296D0A01D797B511AFDAEEEAC53BC61111",
            "OP": "1111006F86FAD6540D86FEF24D261111",
            "IMSI": 999990000000400,
            "ICCID": 999900000000000400,
            "PIN1": "0000",
            "PUK1": "00000000",
            "PIN2": "5555",
            "PUK2": "4444",
            "ADM1": "11111111",
            "ADM6": "11111111",
            "ACC": "0111",
            "DATA_SIZE": 7,
            "PRODUCTION_CHECK": False,
            "ELECT_CHECK": True,
            "GRAPH_CHECK": True,
            "SERVER_CHECK": True,
            "INPUT_PATH": "templates/N2023031016844011.txt",
            "PIN1_RAND": True,
            "PUK1_RAND": True,
            "PIN2_RAND": True,
            "PUK2_RAND": True,
            "ADM1_RAND": True,
            "ADM6_RAND": True,
            "ACC_RAND": True,
        }

        for key, value in params.items():
            setter = getattr(self.params, f"set_{key}")
            setter(value)

    def get_all_parameters(self) -> dict:
        return {
            param: getattr(self.params, f"get_{param}")()
            for param in [
                "PRODUCTION_CHECK",
                "OP",
                "K4",
                "ICCID",
                "IMSI",
                "PIN1",
                "PUK1",
                "PIN2",
                "PUK2",
                "ADM1",
                "ADM6",
                "ACC",
                "DATA_SIZE",
                "INPUT_PATH",
            ]
        }

    def set_headers_from_json(self):
        try:
            data = read_json(CONFIGURATION_FILE_PATH)
            if data:
                self.params.set_SERVER_DICT(
                    list_2_dict(data["PARAMETERS"]["server_variables"])
                )
                self.params.set_ELECT_DICT(
                    list_2_dict(data["PARAMETERS"]["data_variables"])
                )
                self.params.set_GRAPH_DICT(data["PARAMETERS"]["laser_variables"])
                return "Loaded JSON Successfully!"
            return "Failed to load JSON!"
        except Exception as e:
            return str(e)

    def SET_HEADERS(self):
        # this must not be here | remove in revision
        factory_data_json_path = CONFIGURATION_FILE_PATH
        try:
            data = read_json(factory_data_json_path)
            if data:
                header_server_dict = list_2_dict(data["PARAMETERS"]["server_variables"])
                headers_laser_dict = data["PARAMETERS"]["laser_variables"]
                headers_data_dict = list_2_dict(data["PARAMETERS"]["data_variables"])

                self.params.set_SERVER_DICT(header_server_dict)
                self.params.set_ELECT_DICT(headers_data_dict)
                self.params.set_GRAPH_DICT(headers_laser_dict)
                return "Loaded Json Successfull!"
            return "Loaded Json Unuccessfull!"
        except Exception as e:
            return e


from json_utils import JsonHandler

s = DataGenerationScript1()
j = JsonHandler()
factory_data_json_path = CONFIGURATION_FILE_PATH
j.read_paths()
j.read_variables()
s.SET_ALL_DISP_PARAMS()  # testing
s.SET_HEADERS()

(
    s.dataframes.__ELECT_DF,
    s.dataframes.__GRAPH_DF,
    s.dataframes.__SERVR_DF,
    #    s.dataframes.__KEYS,
) = s.generate_all_data()

# print(s.generate_all_data())
print(s.dataframes.__ELECT_DF)
print(s.dataframes.__GRAPH_DF)
# print(s.dataframes.__SERVR_DF)
