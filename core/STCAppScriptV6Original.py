# """
# STC_APP_Scriptv6
#
# Automatically generated by Colaboratory.
#
# Original file is located at
#     https://colab.research.google.com/drive/1Nz_MGqPs5z1rz_G6NBl8xH-dQJxeK1Z3 : Private
#     Author : Hamza Qureshi
#
# DESCRIPTION
# This code include following :
# 1. Create demo data dynamic method
# 2. Generate all parameters added by user from Application/settings.json[Working Fine]
# 3. Get input file
# 4. Create output CSV or Text files [data, laser and server files] as well
# """
#
# # !pip install pycryptodome
# # you can use requirements.txt
# from core.GlobalParams import PARAMETERS, DATA_FRAMES
#
# # from GlobalParams import PARAMETERS, DATA_FRAMES
# # from custom_json import JsonHandler
# from typing import Optional, List, Dict, Any, Tuple
# from Crypto.Cipher import AES
# from io import BytesIO
# import secrets
# import pandas as pd
# import collections
# import binascii
# import datetime
# import random
# import string
# import uuid
# import json
# import time
# import os
#
# CONFIGURATION_FILE_PATH = "settings.json"
#
# # default_headers = [
# #     "ICCID",
# #     "IMSI",
# #     "PIN1",
# #     "PUK1",
# #     "PIN2",
# #     "PUK2",
# #     "KI",
# #     "EKI",
# #     "OPC",
# #     "ADM1",
# #     "ADM6",
# #     "ACC",
# # ]
#
# default_headers = (
#     "ICCID",
#     "IMSI",
#     "PIN1",
#     "PUK1",
#     "PIN2",
#     "PUK2",
#     "KI",
#     "EKI",
#     "OPC",
#     "ADM1",
#     "ADM6",
#     "ACC",
#     "KIC1",
#     "KID1",
#     "KIK1",
#     "KIC2",
#     "KID2",
#     "KIK2",
#     "KIC3",
#     "KID3",
#     "KIK3"
# )
#
# """FUNCTION DEFINITIONS"""
# # Using 16bit zeroes as IV for the AES algo
#
# IV = binascii.unhexlify("00000000000000000000000000000000")
#
#
# def aes_128_cbc_encrypt(key, text):
#     """AES encryption function
#
#     Args:
#         key (str): secret key
#         text (str): text to encrypt
#
#     Returns:
#         str: encrypted text
#     """
#     keyb = binascii.unhexlify(key)
#     textb = binascii.unhexlify(text)
#
#     # ===========================#
#     # ==========E[KI]K4==========#
#     # ===========================#
#
#     encryptor = AES.new(keyb, AES.MODE_CBC, IV=IV)
#     ciphertext = encryptor.encrypt(textb)
#     return ciphertext.hex().upper()
#
#
# def gen_ki():
#     """Generate random key based on uuid4 standard Universally Unique Identifier (UUID)
#     Returns:
#         str: random key of 128 bit in hex form
#     """
#
#     """Changed to secrets reason test report for uuid is not good as compared to secrets """
#     return str(secrets.token_hex(16)).upper()
#
#
# def gen_otas():
#     """Generate random key based on uuid4 standard Universally Unique Identifier (UUID)
#     Returns:
#         str: random key of 128 bit in hex form
#     """
#
#     """Changed to secrets reason test report for uuid is not good as compared to secrets """
#     return str(secrets.token_hex(16)).upper()
#
#
# def gen_k4():
#     """Generate Transport key
#
#     Returns:
#         str: Transport key of size 256 bit
#     """
#     return str(secrets.token_hex(32)).upper()
#
#
# def gen_opc(op, ki):
#     return calc_opc_hex(ki, op).upper()
#
#
# def xor_str(s, t):
#     return bytes([_a ^ _b for _a, _b in zip(s, t)])
#
#
# def calc_opc_hex(k_hex: str, op_hex: str) -> str:
#     """Calculation of OPc from ki(Secret key) and OP ( Operator Variant Algorithm Configuration Field OP)
#     Reference:  TS 135 206 - V14.0.0 Standard
#
#     Args:
#         k_hex (str): Secret key
#         op_hex (str): OP key
#
#     Returns:
#         str: OPc
#     """
#
#     iv = binascii.unhexlify(16 * "00")
#     ki = binascii.unhexlify(k_hex)
#     op = binascii.unhexlify(op_hex)
#     # ===========================#
#     # =========E[OP]k============#
#     # ===========================#
#
#     aes_crypt = AES.new(ki, mode=AES.MODE_CBC, IV=iv)
#
#     data = op
#     # ===========================#
#     # ========E[OP]k^OP==========#
#     # ===========================#
#     o_pc = xor_str(data, aes_crypt.encrypt(data))
#     return o_pc.hex().upper()
#
#
# def gen_eki(transport, ki):
#     return aes_128_cbc_encrypt(transport, ki)
#
#
# def gen_opc_eki(op, transport, ki):
#     return {"opc": gen_opc(op, ki), "eki": gen_eki(transport, ki)}
#
#
# def lenfunc(x):
#     return len(x)
#
#
# def generate_8_Digit():
#     return str(secrets.SystemRandom().randint(10000000, 99999999))
#
#
# # def generate_16_Digit():
# #     return str(secrets.SystemRandom().randint(1000000000000000, 9999999999999999))
#
#
# def generate_4_Digit():
#     return str(secrets.SystemRandom().randint(1000, 9999))
#
#
# def enc_pin_func(x):
#     return rpad(s2h(x), 16).upper()
#
#
# def dec_pin_func(x):
#     return (h2s(x)).upper()
#
#
# def enc_imsi(imsi):
#     imsi = str(imsi)
#     l = half_round_up(
#         len(imsi) + 1
#     )  # Required bytes - include space for odd/even indicator
#     oe = len(imsi) & 1  # Odd (1) / Even (0)
#     ei = "%02x" % l + swap_nibbles("%01x%s" % ((oe << 3) | 1, rpad(imsi, 15)))
#     return ei
#
#
# def dec_imsi(ef):
#     ef = str(ef)
#     if len(ef) < 4:
#         return None
#     l = int(ef[0:2], 16) * 2  # Length of the IMSI string
#     l = l - 1  # Encoded length byte includes oe nibble
#     swapped = swap_nibbles(ef[2:]).rstrip("f")
#     if len(swapped) < 1:
#         return None
#     oe = (int(swapped[0]) >> 3) & 1  # Odd (1) / Even (0)
#     if not oe:
#         l = l - 1
#     if l != len(swapped) - 1:
#         return None
#     imsi = swapped[1:]
#     return imsi
#
#
# Hexstr = str
#
#
# def enc_iccid(iccid: str) -> Hexstr:
#     iccid = str(iccid)
#     luhn = calculate_luhn(iccid)
#     iccid = iccid + str(luhn)
#     m_iccid = swap_nibbles(rpad(iccid, 20))
#     return m_iccid.upper()
#
#
# def dec_iccid(ef: Hexstr) -> str:
#     ef = str(ef)
#     ef = ef.upper()
#     iccid = swap_nibbles(ef).strip("F")
#     return iccid[:-1]
#
#
# def swap_nibbles(s: Hexstr) -> Hexstr:
#     return "".join([x + y for x, y in zip(s[1::2], s[0::2])])
#
#
# def rpad(s: str, l: int, c="f") -> str:
#     return s + c * (l - len(s))
#
#
# def lpad(s: str, l: int, c="f") -> str:
#     return c * (l - len(s)) + s
#
#
# def half_round_up(n: int) -> int:
#     return (n + 1) // 2
#
#
# def calculate_luhn(cc) -> int:
#     num = list(map(int, str(cc)))
#     check_digit = (
#             10 - sum(num[-2::-2] + [sum(divmod(d * 2, 10)) for d in num[::-2]]) % 10
#     )
#     return 0 if check_digit == 10 else check_digit
#
#
# def h2b(s: Hexstr) -> bytearray:
#     return bytearray.fromhex(s)
#
#
# def b2h(b: bytearray) -> Hexstr:
#     return "".join(["%02x" % (x) for x in b])
#
#
# def h2i(s: Hexstr) -> List[int]:
#     return [(int(x, 16) << 4) + int(y, 16) for x, y in zip(s[0::2], s[1::2])]
#
#
# def i2h(s: List[int]) -> Hexstr:
#     return "".join(["%02x" % (x) for x in s])
#
#
# def h2s(s: Hexstr) -> str:
#     return "".join(
#         [
#             chr((int(x, 16) << 4) + int(y, 16))
#             for x, y in zip(s[0::2], s[1::2])
#             if int(x + y, 16) != 0xFF
#         ]
#     )
#
#
# def s2h(s: str) -> Hexstr:
#     b = bytearray()
#     b.extend(map(ord, s))
#     return b2h(b)
#
#
# def i2s(s: List[int]) -> str:
#     return "".join([chr(x) for x in s])
#
#
# def integer_2_ascii(x):
#     return s2h(x)
#
#
# def ascii_2_integer(x):
#     return h2s(str(x))
#
#
# def apply_luhn_check(x):
#     return str(x) + str(calculate_luhn(str(x)))
#
#
# def copy_function(x):
#     return str(x)
#
#
# #  return str("0002")
#
#
# # code below is for Demo Data generation, what if we have to gernate Data from ICCID and IMSI given
# # we have to read input file and copy content [ICCID, IMSI] from input file and generate Parameters based on input File
#
#
# # def read_json(file_path: str):
# #     with open(file_path, "r") as json_file:
# #         data = json.load(json_file)
# #     return dict(data)
#
#
# def read_json(file_path: str):
#     try:
#         with open(file_path, "r") as json_file:
#             data = json.load(json_file)
#         return dict(data)
#     except FileNotFoundError:
#         print(f"Error: File '{file_path}' not found.")
#         return None  # You can choose to return None or raise a custom exception here
#     except json.JSONDecodeError as e:
#         print(f"Error decoding JSON in '{file_path}': {e}")
#         return None  # You can choose to return None or raise a custom exception here
#
#
# class DataGenerationScript:
#     def __init__(self) -> None:
#         self.params = PARAMETERS.get_instance()
#         self.dataframes = DATA_FRAMES.get_instance()
#
#     def __gen_eki_custom(self, x):
#         return gen_eki(self.params.get_K4(), x)
#
#     def __gen_opc_custom(self, x):
#         return gen_opc(self.params.get_OP(), x)
#
#     def __PIN1_function(self, x):
#         return str(self.params.get_PIN1())
#
#     def __PUK1_function(self, x):
#         return str(self.params.get_PUK1())
#
#     def __PIN2_function(self, x):
#         return str(self.params.get_PIN2())
#
#     def __PUK2_function(self, x):
#         return str(self.params.get_PUK2())
#
#     def __ADM1_function(self, x):
#         return str(self.params.get_ADM1())
#
#     def __ADM6_function(self, x):
#         return str(self.params.get_ADM6())
#
#     @staticmethod
#     def __ACC_function(imsi: str) -> str:
#         last_digit = int(imsi[-1])
#         acc_binary = bin(1 << last_digit)[2:].zfill(16)
#         return format(int(acc_binary, 2), "04x")
#
#     @staticmethod
#     def __splitter(input_string):
#         if (
#                 (input_string != "")
#                 and (input_string.find("-") != -1)
#                 and len(input_string) > 2
#         ):
#             values = input_string.split("-")
#         else:
#             values = [0, 32]
#         return int(values[0]), int(values[1])
#
#     def __extract_values(self, t: list):
#         R = []
#         L = []
#         for i in t:
#             left, right = self.__splitter(i)
#             R.append(right)
#             L.append(left)
#         return L, R
#
#     @staticmethod
#     def __return_diplicates(x):
#         return [item for item, count in collections.Counter(x).items() if count > 1]
#
#     def __get_dic_parameter(self, d: dict):
#         va, cl, R, L = ([] for i in range(4))
#         for i in range(len(d.keys())):
#             va.append(list(d.values())[i][0])
#             cl.append(list(d.values())[i][1])
#             R1, L1 = self.__splitter(list(d.values())[i][2])
#             R.append(R1)
#             L.append(L1)
#         va_renamed = self.__append_count_to_duplicates(va)
#         va_duplicate = self.__return_diplicates(va)
#         va_unique = set(va)
#         return va_renamed, va_duplicate, va_unique, cl, R, L
#
#     @staticmethod
#     def __Generate_df_from_list(t_list: list, rows: int):
#         df = pd.DataFrame()
#         d1 = {}
#         for i in range(len(t_list)):
#             d1[str(t_list[i])] = 0
#         new_data = [d1 for i in range(0, rows)]
#         df = pd.concat([df, pd.DataFrame(new_data)], ignore_index=True)
#         return df
#
#     @staticmethod
#     def __append_count_to_duplicates(input_list):
#         output_list = []
#         element_counts = {}
#
#         for element in input_list:
#             if element in element_counts:
#                 element_counts[element] += 1
#                 output_list.append(f"{element}{element_counts[element]}")
#             else:
#                 element_counts[element] = 0
#                 output_list.append(element)
#
#         return output_list
#
#     @staticmethod
#     def __Init_major(df, str1, init_v):
#         for i in range(0, df.shape[0]):
#             # df.loc[i, str1] = str(init_v + i)
#             df.loc[i, str1] = int(init_v + i)
#
#     @staticmethod
#     def __Init_minor(df, str1, init_v):
#         df[str1] = str(init_v)
#
#     def __InitalizeDemoDataFrame(self, df, demo: bool, ICCID_start, IMSI_start):
#         if demo is True:
#             self.__Init_major(df, "ICCID", ICCID_start)  # major with incremetal pattern
#             self.__Init_major(df, "IMSI", IMSI_start)
#         else:
#             self.__Init_major(df, "ICCID", 0)  # major without incremetal pattern
#             self.__Init_major(df, "IMSI", 0)
#
#         self.__Init_major(df, "PIN1", 0)
#         self.__Init_major(df, "PUK1", 0)
#         self.__Init_major(df, "PIN2", 0)
#         self.__Init_major(df, "PUK2", 0)
#         self.__Init_major(df, "KI", 0)
#         self.__Init_major(df, "EKI", 0)
#         self.__Init_major(df, "ADM1", 0)
#         self.__Init_major(df, "ADM6", 0)
#         self.__Init_major(df, "OPC", 0)
#         self.__Init_major(df, "ACC", 0)
#         #  df['len_KI'] = 0
#         #  df['len_EKI'] = 0
#         #  df['len_OPC'] = 0
#         return df
#
#     @staticmethod
#     def __apply_function(df, dest: str, src: str, function):
#         if dest in df.columns:
#             df[dest] = df[src].apply(function).copy(deep=False)
#
#     def __Apply_functions(self, df, op_1, k4_1):
#         #  print(k4_1,op_1)
#         #  apply_function(df,'ICCID','ICCID',apply_luhn_check)
#         self.__apply_function(df, "ICCID", "ICCID", copy_function)
#         self.__apply_function(df, "IMSI", "IMSI", copy_function)
#
#         if self.params.get_PIN1_RAND() is False:
#             self.__apply_function(
#                 df, "PIN1", "PIN1", lambda x: generate_4_Digit()
#             )  # Reason: PIN1 is fixed for now
#         else:
#             self.__apply_function(
#                 df, "PIN1", "PIN1", self.__PIN1_function
#             )  # Reason: PIN1 is fixed for now
#
#         if self.params.get_PUK1_RAND() is False:
#             self.__apply_function(df, "PUK1", "PUK1", lambda x: generate_8_Digit())
#         else:
#             self.__apply_function(df, "PUK1", "PUK1", self.__PUK1_function)
#
#         if self.params.get_PIN2_RAND() is False:
#             self.__apply_function(df, "PIN2", "PIN2", lambda x: generate_4_Digit())
#         else:
#             self.__apply_function(df, "PIN2", "PIN2", self.__PIN2_function)
#
#         if self.params.get_PUK2_RAND() is False:
#             self.__apply_function(df, "PUK2", "PUK2", lambda x: generate_8_Digit())
#         else:
#             self.__apply_function(df, "PUK2", "PUK2", self.__PUK2_function)
#
#         if self.params.get_ADM1_RAND() is False:
#             self.__apply_function(df, "ADM1", "ADM1", lambda x: generate_8_Digit())
#         else:
#             self.__apply_function(df, "ADM1", "ADM1", self.__ADM1_function)
#
#         if self.params.get_ADM6_RAND() is False:
#             self.__apply_function(df, "ADM6", "ADM6", lambda x: generate_8_Digit())
#         else:
#             self.__apply_function(df, "ADM6", "ADM6", self.__ADM6_function)
#
#         self.__apply_function(df, "KI", "KI", lambda x: gen_ki())
#         self.__apply_function(df, "EKI", "KI", self.__gen_eki_custom)
#         #        self.__apply_function(df, "OPC", "EKI", self.__gen_opc_custom)
#         self.__apply_function(df, "OPC", "KI", self.__gen_opc_custom)
#         """ Change made on 30-10-2023 by hamza originally it was as commented """
#
#         self.__apply_function(df, "KIC1", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KIC2", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KIC3", "KI", lambda x: gen_otas())
#
#         self.__apply_function(df, "KID1", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KID2", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KID3", "KI", lambda x: gen_otas())
#
#         self.__apply_function(df, "KIK1", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KIK2", "KI", lambda x: gen_otas())
#         self.__apply_function(df, "KIK3", "KI", lambda x: gen_otas())
#
#         self.__apply_function(df, "ACC", "IMSI", self.__ACC_function)
#
#         return df
#
#     @staticmethod
#     def __drop_extra_columns(list_pass: list, dataframe):
#         columns_to_drop = [col for col in dataframe.columns if col not in list_pass]
#         data = dataframe.drop(columns=columns_to_drop).copy(deep=False)
#         return data
#
#     @staticmethod
#     def __Clip_columns(df, l: list, r: list):
#         count = 0
#         dict2 = {}
#         for col in df.columns:
#             dict2[col] = count
#             count += 1
#         for col in df.columns:
#             df[col] = (
#                 df[col]
#                 .apply(lambda x: x[l[dict2[col]]: r[dict2[col]] + 1])
#                 .copy(deep=False)
#             )
#         return df
#
#     @staticmethod
#     def __add_duplicate_var(df, limit: int, h1: list):
#         for c in range(limit):
#             for col in default_headers:
#                 if col + str(c) in h1:
#                     df[col + str(c)] = df[col].copy(deep=False)
#         return df[h1]  # df[h] reason: to return index of df according to header
#
#     @staticmethod
#     def __Encoding(df):
#         if "ICCID" in df.columns:
#             df["ICCID"] = df["ICCID"].apply(enc_iccid).copy(deep=False)
#         if "IMSI" in df.columns:
#             df["IMSI"] = df["IMSI"].apply(enc_imsi).copy(deep=False)
#         if "PIN1" in df.columns:
#             df["PIN1"] = df["PIN1"].apply(enc_pin_func).copy(deep=False)
#         if "PUK1" in df.columns:
#             df["PUK1"] = df["PUK1"].apply(integer_2_ascii).copy(deep=False)
#         if "PIN2" in df.columns:
#             df["PIN2"] = df["PIN2"].apply(enc_pin_func).copy(deep=False)
#         if "PUK2" in df.columns:
#             df["PUK2"] = df["PUK2"].apply(integer_2_ascii).copy(deep=False)
#         if "ADM1" in df.columns:
#             df["ADM1"] = df["ADM1"].apply(integer_2_ascii).copy(deep=False)
#         if "ADM1" in df.columns:
#             df["ADM6"] = df["ADM6"].apply(integer_2_ascii).copy(deep=False)
#         return df
#
#     @staticmethod
#     def __Decoding(df):
#         if "ICCID" in df.columns:
#             df["ICCID"] = df["ICCID"].apply(dec_iccid).copy(deep=False)
#         if "IMSI" in df.columns:
#             df["IMSI"] = df["IMSI"].apply(dec_imsi).copy(deep=False)
#         if "PIN1" in df.columns:
#             df["PIN1"] = df["PIN1"].apply(dec_pin_func).copy(deep=False)
#         if "PUK1" in df.columns:
#             df["PUK1"] = df["PUK1"].apply(ascii_2_integer).copy(deep=False)
#         if "PIN2" in df.columns:
#             df["PIN2"] = df["PIN2"].apply(dec_pin_func).copy(deep=False)
#         if "PUK2" in df.columns:
#             df["PUK2"] = df["PUK2"].apply(ascii_2_integer).copy(deep=False)
#         if "ADM1" in df.columns:
#             df["ADM1"] = df["ADM1"].apply(ascii_2_integer).copy(deep=False)
#         return df
#
#     def __non_demo(self, default_headers1, op_3, k4_3):
#         # data = self.dataframes.INPUT_DF
#         data = self.dataframes.get_INPUT_DF()
#
#         df1 = self.__Generate_df_from_list(default_headers1, data.shape[0])
#         # df3 = InitalizeDemoDataFrame(df2,demo=demo_Data)
#         #  print([(c, data[c].dtype.kind in 'iufcb') for c in data.columns])
#         df1["ICCID"] = data["ICCID"]
#         df1["IMSI"] = data["IMSI"]
#         #  print("length of ICCID and IMSI are {} {}".format(len(data['IMSI']),len(data['ICCID'])))
#         #  print("Data of ICCID and IMSI are {} {}".format((data['IMSI']),(data['ICCID'])))
#         non_demo_data = self.__Apply_functions(df1, op_3, k4_3)
#         return non_demo_data
#
#     def __is_demo(self, default_headers1, op_3: str, k4_3: str):
#         #  empty_df = Generate_df_from_list(default_headers1,int(size))
#         empty_df = self.__Generate_df_from_list(
#             default_headers1, int(self.params.get_DATA_SIZE())
#         )
#         demo_data_init = self.__InitalizeDemoDataFrame(
#             empty_df,
#             demo=True,
#             ICCID_start=int(self.params.get_ICCID()),
#             IMSI_start=int(self.params.get_IMSI()),
#         )
#         demo_data = self.__Apply_functions(demo_data_init, op_3, k4_3)
#         return demo_data
#
#     def __DATA_PARSER_INITIAL(
#             self, demo_data1: bool, default_headers2: list, op_4, k4_4, keys: bool
#     ):
#         if keys:
#             dict_keys = {"k4": k4_4, "op": op_4}
#         else:
#             dict_keys = {"k4": "", "op": ""}
#         if demo_data1 is True:
#             return self.__is_demo(default_headers2, op_4, k4_4), dict_keys
#
#         if demo_data1 is False:
#             return self.__non_demo(default_headers2, op_4, k4_4), dict_keys
#
#     def __DATA_PARSER_FINAL(
#             self, input_dict: dict, df_input, clip: bool, encoding: bool, caption: str
#     ):
#         (
#             laser_h,
#             laser_d_h,
#             laser_unique,
#             laser_c,
#             laser_l,
#             laser_r,
#         ) = self.__get_dic_parameter(input_dict)
#         df20 = df_input.copy(deep=False)
#         if encoding is True:
#             emcoded_df = self.__Encoding(df20)
#         else:
#             emcoded_df = df20.copy(deep=False)
#         #  print(laser_l)
#         #  print(laser_r)
#
#         dupl_var_encoded_df = self.__add_duplicate_var(emcoded_df, 10, laser_h)
#         dupl_var_encoded_df = dupl_var_encoded_df.copy(deep=False)
#         # df23 = drop_extra_columns(laser_h,df7)
#         # df24 = df22.copy(deep=False)
#         if clip is True:
#             final_df = self.__Clip_columns(dupl_var_encoded_df, laser_l, laser_r)
#         else:
#             final_df = dupl_var_encoded_df.copy(deep=False)
#         #  final_df.style.set_caption("|=="+caption+"==|")
#         return final_df
#
#     def __LASER_DATA_EXTRACTOR(
#             self, input_dict: dict, df_input, clip: bool, encoding: bool, caption: str
#     ):
#         (
#             laser_h,
#             laser_d_h,
#             laser_unique,
#             laser_c,
#             laser_l,
#             laser_r,
#         ) = self.__get_dic_parameter(input_dict)
#         df20 = df_input.copy(deep=False)
#         if encoding is True:
#             emcoded_df = self.__Decoding(df20)
#         else:
#             emcoded_df = df20.copy(deep=False)
#         #  print(laser_l)
#         #  print(laser_r)
#
#         dupl_var_encoded_df = self.__add_duplicate_var(emcoded_df, 10, laser_h)
#         dupl_var_encoded_df = dupl_var_encoded_df.copy(deep=False)
#         # df23 = drop_extra_columns(laser_h,df7)
#         # df24 = df22.copy(deep=False)
#         if clip is True:
#             final_df = self.__Clip_columns(dupl_var_encoded_df, laser_l, laser_r)
#         else:
#             final_df = dupl_var_encoded_df.copy(deep=False)
#         #  final_df.style.set_caption("|=="+caption+"==|")
#         return final_df
#
#     # ===========================================#
#     # ===================SET=====================#
#     # ===========================================#
#     def SET_ALL_DISP_PARAMS(self):
#         self.params.set_K4(
#             "111150987DE41E9F0808193003B543296D0A01D797B511AFDAEEEAC53BC61111"
#         )
#         self.params.set_OP("1111006F86FAD6540D86FEF24D261111")
#         self.params.set_IMSI(999990000000400)
#         self.params.set_ICCID(999900000000000400)
#         self.params.set_PIN1("0000")
#         self.params.set_PUK1("00000000")
#         self.params.set_PIN2("5555")
#         self.params.set_PUK2("4444")
#         self.params.set_ADM1("11111111")
#         self.params.set_ADM6("11111111")
#         self.params.set_ACC("0111")
#         self.params.set_DATA_SIZE(7)
#
#         self.params.set_PRODUCTION_CHECK(False)
#         self.params.set_ELECT_CHECK(True)
#         self.params.set_GRAPH_CHECK(True)
#         self.params.set_SERVER_CHECK(True)
#
#         # self.params.set_SERVER_DICT(input_server_params)
#         # self.params.set_ELECT_DICT(input_elect_params)
#         # self.params.set_GRAPH_DICT(input_laser_params)
#         #  params.set_INPUT_PATH("C:/Users/hamza.qureshi/Desktop/STC_APP/improvements/dataGen-v17/input.csv")
#         self.params.set_INPUT_PATH("templates/N2023031016844011.txt")
#
#         # ========================================#
#         # ========================================#
#         # ========================================#
#
#         self.params.set_PIN1_RAND(False)
#         self.params.set_PUK1_RAND(True)
#         self.params.set_PIN2_RAND(False)
#         self.params.set_PUK2_RAND(False)
#         self.params.set_ADM1_RAND(False)
#         self.params.set_ADM6_RAND(True)
#         self.params.set_ACC_RAND(False)
#
#     # ===========================================#
#     # ==================GET======================#
#     # ===========================================#
#
#     # parameter_dict={
#     #   "Demo Data":"","OP":"","K4":"","ICCID":"","IMSI":"",
#     #   "PIN1":"","PUK1":"","PIN2":"","PUK2":"","ADM1":"",
#     #   "ADM6":"","ACC":"","DATA_SIZE":""}
#     def GET_ALL_PARAMS_DICT(self) -> dict:
#         param_dict = {}
#         param_dict["Demo Data"] = self.params.get_PRODUCTION_CHECK()
#         param_dict["OP"] = self.params.get_OP()
#         param_dict["K4"] = self.params.get_K4()
#         param_dict["ICCID"] = self.params.get_ICCID()
#         param_dict["IMSI"] = self.params.get_IMSI()
#         param_dict["PIN1"] = self.params.get_PIN1()
#         param_dict["PUK1"] = self.params.get_PUK1()
#         param_dict["PIN2"] = self.params.get_PIN2()
#         param_dict["PUK2"] = self.params.get_PUK2()
#         param_dict["ADM1"] = self.params.get_ADM1()
#         param_dict["ADM6"] = self.params.get_ADM6()
#         param_dict["ACC"] = self.params.get_ACC()
#         param_dict["DATA_SIZE"] = self.params.get_DATA_SIZE()
#         param_dict["INPUT_PATH"] = self.params.get_INPUT_PATH()
#         return param_dict
#
#     def _preview_files_gets(self):
#         Initial_DataFrame = pd.DataFrame()
#         Initial_DataFrame, keys_dict = self.__DATA_PARSER_INITIAL(
#             demo_data1=self.params.get_PRODUCTION_CHECK(),
#             default_headers2=default_headers,
#             op_4=self.params.get_OP(),
#             k4_4=self.params.get_K4(),
#             keys=True,
#         )
#         print("Keys used in this data generation attempt are : ")
#         print(keys_dict)
#         laser_df = pd.DataFrame()
#         elect_df = pd.DataFrame()
#         server_df = pd.DataFrame()
#
#         if self.params.get_SERVER_CHECK() is True:
#             server_df = self.__DATA_PARSER_FINAL(
#                 self.params.get_SERVER_DICT(),
#                 Initial_DataFrame,
#                 clip=False,
#                 encoding=False,
#                 caption="SERVER",
#             )
#         if self.params.get_GRAPH_CHECK() is True:
#             laser_df = self.__DATA_PARSER_FINAL(
#                 self.params.get_GRAPH_DICT(),
#                 Initial_DataFrame,
#                 clip=True,
#                 encoding=False,
#                 caption="LASER",
#             )
#         if self.params.get_ELECT_CHECK() is True:
#             elect_df = self.__DATA_PARSER_FINAL(
#                 self.params.get_ELECT_DICT(),
#                 Initial_DataFrame,
#                 clip=False,
#                 encoding=True,
#                 caption="ELECT",
#             )
#
#         return elect_df, laser_df, server_df, keys_dict
#
#     def SET_HEADERS(self):
#         # this must not be here | remove in revision
#         factory_data_json_path = CONFIGURATION_FILE_PATH
#         try:
#             data = read_json(factory_data_json_path)
#             if data:
#                 header_server_dict = list_2_dict(data["PARAMETERS"]["server_variables"])
#                 headers_laser_dict = data["PARAMETERS"]["laser_variables"]
#                 headers_data_dict = list_2_dict(data["PARAMETERS"]["data_variables"])
#
#                 self.params.set_SERVER_DICT(header_server_dict)
#                 self.params.set_ELECT_DICT(headers_data_dict)
#                 self.params.set_GRAPH_DICT(headers_laser_dict)
#                 return "Loaded Json Successfull!"
#             return "Loaded Json Unuccessfull!"
#         except Exception as e:
#             return e
#
#
# # input_laser_params = {
# #     "0": ["ICCID", "Right", "0-31"],
# #     "1": ["ICCID", "Right", "0-31"],
# #     "2": ["ICCID", "Right", "0-31"],
# #     "3": ["ICCID", "Right", "0-31"],
# #     "4": ["ICCID", "Right", "0-31"],
# #     "5": ["IMSI", "Right", "0-31"],
# #     "6": ["IMSI", "Right", "0-31"],
# # }
# # input_server_params = {}
# # input_elect_params = {
# #     "0": ["ICCID", "Normal", "0-19"],
# #     "1": ["IMSI", "Normal", "0-14"],
# #     "2": ["PIN1", "Normal", "0-3"],
# #     "3": ["PUK1", "Normal", "0-7"],
# #     "5": ["PIN2", "Normal", "0-3"],
# #     "6": ["PUK2", "Normal", "0-7"],
# #     "7": ["ADM1", "Normal", "0-7"],
# #     "8": ["ADM6", "Normal", "0-7"],
# #     "10": ["EKI", "Normal", "0-31"],
# #     "11": ["OPC", "Normal", "0-31"],
# #     "12": ["ACC", "Normal", "0-3"],
# # }
#
#
# # ==============================================================#
# # ========================LASER DATA============================#
# # ==============================================================#
#
#
# # ==============================================================#
# # =====================ELECTRICAL DATA==========================#
# # ==============================================================#
#
#
# def list_2_dict(list: list) -> dict:
#     dict = {}
#     for index in range(0, len(list)):
#         dict[str(index)] = [list[index], "Normal", "0-31"]
#     return dict
#
#
# def dict_2_list(d: dict) -> list:
#     list1 = []
#     for index, j in enumerate(d):
#         temp = list(d.values())[index][0]
#         list1.append(temp)
#     return list1
#
#
# # # input_elect_params = {
# # #     "0": ["ICCID", "Normal", "0-18"],
# # #     "1": ["ICCID", "Normal", "10-20"],
# # #     "2": ["ICCID", "Normal", "0-14"],
# # #     "3": ["IMSI", "Normal", "0-14"],
# # #     "4": ["PIN1", "Normal", "0-14"],
# # # }
#
#
# # from operators.zong.FileParser import ZongFileParser
# # from json_utils import JsonHandler
# #
# # s = DataGenerationScript()
# # j = JsonHandler()
# # factory_data_json_path = CONFIGURATION_FILE_PATH
# # j.read_paths()
# # j.read_variables()
# # s.SET_ALL_DISP_PARAMS()  # testing
# # s.SET_HEADERS()
# #
# # (
# #     s.dataframes.__ELECT_DF,
# #     s.dataframes.__GRAPH_DF,
# #     s.dataframes.__SERVR_DF,
# #     s.dataframes.__KEYS,
# # ) = s._preview_files_gets()
# #
# # print(s.dataframes.__ELECT_DF)
# # print(s.dataframes.__GRAPH_DF)
# # print(s.dataframes.__SERVR_DF)
# #
# # # # m_zong = ZongGenerateHandle()
# #
# # # # m_zong.set_json_to_UI()
# # # # m_zong.Generate_laser_file("AAA",s.dataframes.GRAPH_DF)
# # # # m_zong.Generate_servr_file("ASD",s.dataframes.SERVR_DF)
# # # # m_zong.Generate_elect_file("ASD",s.dataframes.ELECT_DF)
